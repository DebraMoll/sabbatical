<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    "use strict";

    function log(arg) {
        document.write(arg);
    }
    function logbr(arg){
        document.write("<br/>" + arg + "<br/>");
    }
    function lognl(){
        document.write("<br/>");
    }

    function identity(x) {
        return x;
    }

    log(identity(3));


    function add(x, y) {
        return x + y;
    }

    function sub(x, y) {
        return x - y;
    }

    function mul(x, y) {
        return x * y;
    }

    log("<br/>add(3,4):<br/>")
    log(add(3,4));
    log("<br/>sub(3,4):<br/>")
    log(sub(3,4));
    log("<br/>mul(3,4):<br/>")
    log(mul(3,4));

    //Identityf function that takes an argument and returns a function that returns the argument
    function identityf(self) {
        return function() {
            return self;
        };
    }

    log("<br/>identityf(3) where identityf returns a function which returns the arg of identityf:<br/>")
    log("NOTE: the new function returned is lifted as a variable on the heap. The orig function's argument, self, stays around<br/>")
    log("on the heap, which is how the new function three(x) knows about x and can return it<br/>")
    log("call idenityf(3) and note how it returns a function:<br/><br/>")
    log(identityf(3));
    log("<br/>");

    var three = identityf(3);

    log("<br/>create identityf(self) that returns self and then create three() that equals identifyf(3). call three(): <br/>")
    log(three());

    //Function addf that adds from two invocations, addf(3)(4) returns 7. send 3 into addf which returns a function.
    //now send in 4 to the new function which returns 7. i.e. add 3 and 4
    function addf(x) {
        return function(y) {
            return add(x,y);
        };
    }
    var addf3 = addf(3);
    log("<br/> create addf3=addf(3) where addf returns a function that accepts one argument and returns sum(x,y) and then call three():<br/>")
    log(addf(3));
    log("<br/>now call addf3(9) which should now return 12:<br/>");
    log(addf3(9));
    log("<br/>");

    //Create function liftf that takes a binary function and makes it callable with two invocations
    //var addf = liftf(add);
    //addf(3)(4); //7
    //liftf(mul)(5)(6); //30
    function liftf(binaryFunc) {
        return function(x){
            return function(y) {
                return binaryFunc(x,y);
            };
        };
    }
    log("<br/>definition of liftf():<br>");
    log(liftf());
    log("<br/>");
    var addf = liftf(add);
    logbr("set addf = liftf(add); definition of addf:")
    log("<br/>");
    log(addf())
    logbr("addf(3)(4):")
    log(addf(3)(4));
    log("<br/>")
    logbr("call liftf(mul(5)(6)):")
    log(liftf(mul)(5)(6));
    log("<br/>")

    //Create a function curry that accepts a binary function and an argument and returns a function that
    //accepts and argument on which the binary function acts
    //eg. curry(mul,5)(6) //30
    //NOTE: currying comes from the mathematicial curry who felt that all functions should be normalized to
    //accpt only one argument
    function curry1(binaryFunc, x){
        return function(y) {
            return binaryFunc(x, y);
        };
    }
    log("<br/>")
    log("curry1 function:<br/>")
    log(curry1());
    log("<br/>call curry1(mul,5)(6):<br/>")
    log(curry1(mul,5)(6));
    log("<br/>")

    //or for curry we can do
    function curry2(binaryFunc, x) {
        return liftf(binaryFunc)(x);
    }
    log("<br/>")
    log("curry2 function using liftf:<br/>")
    log(curry2(mul,5)(6));
    log("<br/>")


    //write a function twice that takes a binary function and returns a unary function that passes its argument
    //to the binary function twice
    //e.g. doubl=twice(add); doubl(11); returns 22
    function twice(binFunc) {
        return function(x) {
            return binFunc(x,x);
        }
    }
    var doubl = twice(add);
    var square = twice(mul);
    logbr("function twice:");
    log(twice());
    log("<br/>");
    logbr("call doubl(11) = :");
    log(doubl(11));
    logbr("twice(mul)(11)=");
    log(twice(mul)(11));

    function reverse(binFunc) {
        return function(x,y) {
            return binFunc(y,x);
        }
    }
    logbr("reverse():");
    log(reverse());
    logbr("reverse(sub)(3,2)=");
    log(reverse(sub)(3,2));

    function composeu(uniFunc1, uniFunc2){
        return function(x) {
            return uniFunc2(uniFunc1(x));
        }
    }
    lognl();
    logbr("composeu(doubl, square)(5) expect 100, returned: ");
    log(composeu(doubl,square)(5));

    function composeb(b1, b2) {
        return function (x,y,z){
            return b2(b1(x, y), z);
        }
    }
    lognl;
    logbr("composeb(add,mul)(3,4,5)=");
    log(composeb(add,mul)(3,4,5));

    //function that accepts a binary function and a limit on the number of times it can be called
    function limit(b, count) {
        return function(x, y) {
            if(count >= 1){
                count -= 1;
                return b(x,y);
            }
            //return undefined;
        }
    }

    var mul_ltd = limit(mul, 2);
    lognl();
    logbr("create mul_ltd = limit(mul, 2) and then call mul_ltd(3,4) 3 times and validate that the third time gets undefined")
    log(mul_ltd(3,4));
    lognl();
    log(mul_ltd(3,4));
    lognl();
    log(mul_ltd(3,4));
    lognl();

</script>

</body>
</html>